#version 460
#extension GL_EXT_ray_tracing : enable
/*
struct Vertex {
    vec3 position;
    vec3 normal;
    vec3 color;
};

layout(set = 0, binding = 0) buffer Vertices {
    Vertex vertices[];
} vertexBuffer;
*/


layout(set = 0, binding = 1) buffer Matrices {
    mat4 modelMatrix;
} matrices;

layout(binding = 2, set = 0) uniform accelerationStructureEXT TLAS;

layout(set = 0, binding = 3) uniform CameraData {
    mat4 viewMatrix;
    mat4 projectionMatrix;
    vec3 cameraPosition;
} cameraData;

struct RayPayload {
    vec3 rayDir;   // Dirección del rayo
};

layout(location = 5) rayPayloadEXT RayPayload RayInformationpayload;
layout(location = 0) rayPayloadEXT  vec4 payload;
layout(set = 0, binding = 4, rgba8) uniform image2D img;
void main() {

    /*ivec2 pixelCoord = ivec2(gl_LaunchIDEXT.xy);
    vec2 normalizedCoord = (vec2(pixelCoord) + vec2(0.5)) / vec2(imageSize(img)); // Normalizar coordenadas de píxeles
    normalizedCoord = normalizedCoord * 2.0 - vec2(1.0); // Ajustar a rango [-1, 1]

    // Desproyectar las coordenadas para obtener la dirección del rayo en el espacio del mundo
    vec4 rayClip = vec4(normalizedCoord, -1.0, 1.0);
    vec4 rayEye = inverse(cameraData.projectionMatrix) * rayClip;
    rayEye = vec4(rayEye.xy, -1.0, 0.0);
    vec3 rayDir = normalize((inverse(cameraData.viewMatrix) * rayEye).xyz);
    RayInformationpayload.rayDir = rayDir;


    // Preparar para trazar el rayo
    uint rayFlags = gl_RayFlagsOpaqueEXT | gl_RayFlagsTerminateOnFirstHitEXT;
    float tMin = 0.01;  // Comenzar a trazar desde una pequeña distancia de la cámara para evitar auto-intersección
    float tMax = 1000.0; // Máxima distancia del rayo

    // Trazar el rayo
    traceRayEXT(
        TLAS,            // Estructura de aceleración
        0xff,        // Flags del rayo
        0,               // Culling mask
        0,               // SBT record offset
        0,               // SBT record stride
        0,               // Miss index
        cameraData.cameraPosition,  // Origen del rayo
        tMin,            // tMin
        rayDir,          // Dirección del rayo
        tMax,            // tMax
        0                // Payload location
    );
*/
    // Usar los datos de 'payload' para escribir en la imagen
    // Por ejemplo, si 'payload' contiene un color basado en la intersección
    //imageStore(img, pixelCoord, payload);
    
    
    vec4 color = vec4(1.0,0.0,0.0, 1.0); // Color rojo fijo
    ivec2 pixelCoord = ivec2(gl_LaunchIDEXT.xy);
    imageStore(img, pixelCoord, color);
}

